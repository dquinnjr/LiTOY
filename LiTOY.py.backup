#!/usr/bin/env python3

import time
import sqlite3
import random
import pyfiglet
import logging
logging.basicConfig(level=logging.INFO, filename = 'debug.log', filemode='a', format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')



##################################### TODO
'''

        utiliser plusieurs fichiers pour coder, antoine t'a convaincu
        poster sur github en mode privé, ca t'aidera a t'organiser
        comprendre ce que c'est que le locking d'une db, l'interet etc
        rajouter un champs type (text / video / audio / manual) 
               le time to read doit etre time to watch si il s'agit d'une video, utiliser youtube-dl pour trouver la durée si url, ou ffmpeg si c'est un fichier local
               si c'est un pdf : utiliser pdftotext puis le code pour estimer le temps pour lire une page web
        don't pick if card disabled
        prendre le temps de reflechir et repondre a ce message https://www.lesswrong.com/posts/54Bw7Yxouzdg5KxsF/how-do-you-organise-your-reading
        rajouter une syntaxe pour importer avec directement des infos : __length=37pages   __length=17minutes __catgeroy=audio etc et surtout __1/2/3/4 indique si on lui donne par défaut le score du premier 2e 3e ou 4e cinquieme du classement
        il faut qu'un raccourci permette d'ouvrir automatiquement les url dans un navigateur + que ca soit configurable
        organiser un autre fichier contenant la todo list, dont une section "long term ideas", ex :
               penser a rajouter un mode "court terme" qui permet simplement de trier des trucs selon lequel doit etre fait en premier
        rewrite the long SQL request so that it's on multiple lines
        verifier par le calcul que l'ordre dans lequel on fait les combats n'a pas d'importance, ca conditionne la maniere dont tu stockes les resultats
        champs "estimated time to read" + "title of url"
            faut que ca marche aussi si plusieurs url sont données
        verifier que chaque message important est dans le log
        si importé a partir d'un fichier : bouger le fichier dans un dossier ./imported/+date
        les tupple sont plus rapides que les listes, les priviléger
        dans l'url : au cas ou : changer ` en '
        il faut en fait rajouter genre 5 fois des fields qui soit score1/2/3/4/5, score_name et l'utiliser pour faire des trucs plus cmoplexes genre noter des films rapidement, car prendre en compte la taille de fichier video serait ouf
        il faut rajouter une valeur "average" dans les scores qui serait automatiquement transformée en la moyenne des scores correspondant, par exemple pour si tu as un dvd dans une liste de fichier films, tu auras pas la taille du dvd mais tu auras sa longueur et son importance donc ca ferait foirer la formule
        function that automatically checks fields consistency :
             estimated time to read
             title of url
             delta
             presence of importance score
             check for duplicates in url
             presence of time score
             nb of time of importance score is the same as nb of time score
             same for importance
        keep log size < 5MB or compress it
        faire des simulations avec une fausse liste d'item du genre [nombre de 1 a 100 ; nombrer random de 1 a 100]
            utiliser ca pour avoir une idée de la vitesse de convergence
                    utiliser plusieurs valeurs de K
                        tester avec un truc genre "90% de chance de donner la bonne réponse" pour voir comment les real worls data diffèrent des stats theoriques
        use different color for the prompt and the display, to make it more readable and overall nicer to read
        idée : en fait on peut avoir un score par question, et permettre de rajouter des question tout seul non ? voir a la longue si ca serait reelement utile
        if url is found : compute estimated time to read
             if url not found : use waybackmachine
        racourci qui ouvre sqlite browser
        fonction qui choppe/stocke une/plusieurs valeur de la db
          fixer les valeurs initiales de la db
            demander si on veut d'emblées rajouter une categorie lors de l'importation en affichant les categories deja existantes
        tirage au sort du plus grand differentiel
        pour corriger un field : https://stackoverflow.com/questions/2533120/show-default-value-for-editing-on-python-input-possible/2533142#2533142
        calcul de la moyenne  des differentiels
        auto backup a chaque changement de details/category/title etc
        permettre d'exporter la liste or something, eventuellement en format ical, ou format anki
        idée de flo : exporter vers maniana (en tout cas il faut jeter un oeil pour voir ce que c'est) https://f-droid.org/fr/packages/com.zapta.apps.maniana/ 
        il faut que ca affiche le nombre de truc a faire qui sont todo, et si ca croit ou decroit sur 7 jours
        pour la cli : ce truc a l'air cool pour afficher le tables des podiums : http://zetcode.com/python/prettytable/
        pour l'interface une fois que tu as verifie que ca marche bien en cli : apprendre pyqt, clairement ce sera le plus simple et ca t'ouver la porte vers completer anki
        regarder si il y a pas un moyen plus simple que de faire une backup, genre un moyen de faire des unfo a l'infini ou de garder un historique
        rajouter un champs winAgainst et loseAainst, on rajoute l'id de l'adversaire dans le field a chaque combat, ca semble utile pour "refaire" des tris" apres coups ; pas encore sur d'a quoi ca sert mais il faut compter les draws aussi
        idée d'antoine pour l'interface : permettre des command line command genre : litoy set ID --category "truc" ou litoy list --time ou litoy fight -n=50  ou litoy import file  ou   litoy backup    ou    litoy status   ou    litoy testrun 
        noter quelque part que si litoy marche bien il faudra le compatibiliser avec Polar, soit le rendre ineractif (genre qu'il recup des data de polar) soit carrement en le recodant a l'interieur

aide SQL  https://pynative.com/python-sqlite-select-from-table/
          http://www.easypythondocs.com/SQL.html
          https://cheatography.com/explore/search/?q=sqlite

field order :
        1 date added
        2 entry
        3 details
        4 category
        5 starred
        6 progress
        7 importance elo
        8 date importance elo
        9 time_elo
        10 date time elo
        11 delta importance
        12 delta time
        13 global score
        14 time spent comparing
        15 number of comparison
        16 disabled
        17 done
        18 K_value

'''
##################################### SETTINGS : 

user_age = "23"
user_life_expected = "75"

#question_importance = "What steps will actually make you likely to achieve your goals?\n* Which is more important?\n* If you had one hour to spend, which would bring you more in your life?"
#question_time = "Which task takes the less time to complete?"
#question_ranking = "Which task should be done first?"
questions = {"importance" : "What steps will make you likely to achieve your goals?\n* Which is more important?\n* If you had one hour to spend, which would bring you more in your life?",
        "time" : "Which task takes the less time to complete?",
        "ranking" : "Which task should be done first?",}

shortcut = {
        "skip_fight"                 :  ["s","-"],
        "answer_level"               :  ["1","2","3","4","5","a","z","e","r","r","t"],
        "cycle_display_options"      :  "q",
        "edit_entry"                 :  "s",
        "edit_details"               :  "d",
        "undo_fight"                 :  "f",
        "mark_left"                  :  "w",
        "mark_right"                 :  "x",
        "disable_card_because_done"  :  "C",
        "disable_card_because_else"  :  "c",
        "show_help"                  :  ["h","?"]
        }

K_values           =  [100,50,25,15,10]
default_score      =  "1000"
adjustment_factor  =  "1"                #  used  in  the  global  score  formula
choice_threshold   =  0.25               #  X%    of  the  time    :      the      card  used  the  least  recently  will  be  picked

##################################### Functions :
###################### SQL related :


def import_from_txt(filename, category) :
        with open(filename) as f: # reads line by line
            content = f.readlines()
            content = [x.strip() for x in content] # removes \n character
            content = list(dict.fromkeys(content))

        # get a new and unused id for the new cards
        cursor.execute(''' SELECT max(ID) FROM LiTOY ''')
        newID = str(cursor.fetchone()[0])
        if newID == "None" :
            newID = "1"

        # importation
        for entry in content :
                entry = entry.replace("'","`") # otherwise it messes with the SQL

                unixtime = str(int(time.time())) # creation date of the entry

                query_exists = "SELECT ID FROM LiTOY WHERE entry = '"+entry + "'"
                cursor.execute(query_exists)
                existence = "False"
                try :
                    existence = str(cursor.fetchone()[0])
                except :
                    existence = "False"
                if existence == "False" :
                    query_create = "INSERT INTO LiTOY(ID, date_added, entry, time_spent_comparing, number_of_comparison, starred, category, disabled, done, K_value) VALUES (" + newID + ", " + unixtime + ", \'" + entry + "\', 0, 0, 0, '" + str(category) + "', 0, 0" + K_values[0] + ")"
                    cursor.execute(query_create)
                    print(" ## Entry imported : '" + entry + "'")
                    logging.info(" ## Entry imported : '" + entry + "'")
                else :
                    print(" ## Entry already exists in db : '" + entry + "'")
                    logging.info(" ## Entry already exists in db : '" + entry + "'")
                newID = str( int(newID)+1)
        db.commit()
        db.close()
        logging.info("Done importing\n")

def get_category() : # tested OK
    logging.info("Getting category list...")
    db = sqlite3.connect('LiTOY.db') ; cursor = db.cursor()
    query_get_cat = "SELECT category FROM LiTOY"
    cursor.execute(query_get_cat)
    categories = cursor.fetchall()
    categories = list(set(categories)) # remove duplicates
    new_list = categories
    for i,t in enumerate(categories) :
        new_list[i] = str(t).replace(",", "")
    db.commit()
    db.close()
    logging.info("Done getting category list\n")
    return ' '.join(new_list)

def get_sql_value(variable="*", condition="") : # tested OK
    db = sqlite3.connect('LiTOY.db') ; cursor = db.cursor()
    if condition == "" : query_ending = ""
    else : query_ending = " WHERE " + condition
    query_get = "SELECT " + variable + " FROM LiTOY" + query_ending
    #print(query_get)
    cursor.execute(query_get)
    logging.info(str("SQL GET REQUEST : " + query_get))
    result = cursor.fetchall()
    if len(result) == 1 :
        result = result[0]
    db.commit()
    db.close()
    return result

def put_sql_value(which, variable, new_value) : #tested OK
    db = sqlite3.connect('LiTOY.db') ; cursor = db.cursor()
    query_put = "UPDATE LiTOY SET "+ variable + " = '" + new_value + "' WHERE " + which
    cursor.execute(query_put)
    logging.info(str("SQL PUT REQUEST : " + query_put))
    db.commit()
    db.close()

def update_delta(entry_id) : # Tested OK
    logging.info("Updating delta for entry id "+entry_id)
#    db = sqlite3.connect('LiTOY.db') ; cursor = db.cursor()
#    cursor.execute("SELECT id, importance_elo, time_elo from LiTOY WHERE id =" + str(entry_id))
#    result = cursor.fetchall()[0]
    result = get_sql_value("id, importance_elo, time_elo","id = " + str(entry_id[0]))
#    db.commit()
#    db.close()
    importance_delta = str(int(result[1].split(sep='_')[-1]) - int(result[1].split(sep='_')[-2]))
    time_delta = str(int(result[2].split(sep='_')[-1]) - int(result[2].split(sep='_')[-2]))

    current_imp_delta = str(get_sql_value("delta_imp", "id = "+entry_id))
    if current_imp_delta != importance_delta :
        put_sql_value("id = " + entry_id, "delta_imp", importance_delta)
    else : logging.info("Importance delta already up to date for id " + entry_id)
    current_time_delta = str(get_sql_value("delta_time", "id = "+entry_id))
    if current_time_delta != time_delta :
        put_sql_value("id = " + entry_id, "delta_time", time_delta)
    else : logging.info("Time delta already up to date for id " + entry_id)
    logging.info("Done updating deltas\n")

def set_db_defaults_value(): # tested OK
    logging.info("Setting fields to their default value if needed :")
    var = get_sql_value("id, importance_elo, time_elo, done", "id >= 0")
#    for i,content in enumerate(var) :
#        entry_id = str(var[i][0])
#        importance_elo = str(var[i][1])
#        time_elo = str(var[i][2])
#        done_field = str(var[i][3])
#        if time_elo == "None" :
#            put_sql_value("id = " + entry_id, "time_elo", "0_"+default_score)
#        if importance_elo == "None" :
#            put_sql_value("id = " + entry_id, "importance_elo", "0_"+default_score)
#        if done_field == "1" :
#            put_sql_value("id = " + entry_id, "disabled", "1")
    entry_id = str(var[0])
    importance_elo = str(var[1])
    time_elo = str(var[2])
    done_field = str(var[3])
    if time_elo == "None" :
        put_sql_value("id = " + entry_id, "time_elo", "0_"+default_score)
    if importance_elo == "None" :
        put_sql_value("id = " + entry_id, "importance_elo", "0_"+default_score)
    if done_field == "1" :
        put_sql_value("id = " + entry_id, "disabled", "1")

    logging.info("Done setting fields to default value\n")


###################### Elo related :

# tested : not tested but probably OK
def expected(elo_A, elo_B, Rp=100):
      '''Calculate expected score of A in a best of 3 match against B
       Expected score of B in a best of 3 match against A is given by 1-expected(A,B,Rp)
      For each Rp rating points of advantage over the opponent, the expected score is magnified ten times   in comparison to the opponent's expected score '''
      return 3 / (1 + 10 ** ((elo_B - elo_A) / Rp))


def update_elo(elo, exp_score, real_score, K):
      return elo + K*(real_score - exp_score)

def adjust_K(K0): # tested : OK
    if K0 == K_values[-1] :
        print("K already at last specified value : " + str(K0) + " == " + str(K_values[-1]))
        logging.info("K already at last specified value : " + str(K0) + " == " + str(K_values[-1]))
        return K0
    for i in range(len(K_values)):
        if K_values[i] == K0 :
            return K_values[i+1]
        else :
            print("error : K not part of K_values : "+ str(K0))
            logging.info("error : K not part of K_values : "+ str(K0) + ", reset to " +str(K_values[-1]))
            return K_values[-1]

###################### remaining :

def print_entry(entry_id):
    entry_fields = get_sql_value("*","id = " + str(entry_id))
    print ("Category : " + str(entry_fields[4]))
    print ("Entry : " + str(entry_fields[2]))
    if entry_fields[3] != "None" : print ("Details : " + str(entry_fields[3]))
    if entry_fields[6] != "None" :     print ("Progress : " + str(entry_fields[6]))
    #print ("Importance Elo : " + str(entry_fields[7]))
    #print ("Time Elo : " + str(entry_fields[9]))

def print_entry_all_fields(entry_id):
    entry_fields = get_sql_value("*","id = " + str(entry_id))
    for i,f in enumerate(entry_fields):
        print(str(i) + " ___ " + str(f))


def choose_fighting_entries(mode, condition=""): # tested seems OK
    condition = "disabled IS 0 AND " + condition
    all_ids_deltas_dates = get_sql_value("id, delta_imp, delta_time, date_importance_elo, date_time_elo, disabled",condition)
    if mode == "i" : mode = 1
    if mode == "t" : mode = 2
    all_ids_deltas_dates = list(all_ids_deltas_dates)
    #print(all_ids_deltas_dates)
    all_ids_deltas_dates.sort(reverse=True, key=lambda x : x[mode])
    highest_5_deltas = all_ids_deltas_dates[0:5]
    choice1 = random.choice(highest_5_deltas)
    randomness = random.random()
    if randomness > choice_threshold :
        while 1==1 :
            choice2 = random.choice(all_ids_deltas_dates)
            if choice2[0] == choice1[0]:
                print("Re choosing : selected the same entry")
                continue
            break
    else :
        print("Choosing the oldest seen entry")
        logging.info("Choosing the oldest seen entry")
        while 1==1 :
            all_ids_deltas_dates.sort(reverse=False, key=lambda x : str(x[mode+2]).split(sep="_")[-1])
            choice2 = all_ids_deltas_dates[0]
            while choice2[0] == choice1[0]:
                print("Re choosing : selected the same entry")
                choice1 = random.choice(highest_5_deltas)
            break
    return [choice1[0], choice2[0]]

def shortcut_reaction(key, mode, fighters):
    def get_key(val): 
        for key, value in my_dict.items(): 
             if val == value: 
                 return key 

    while 1==1 :
        logging.info("User types =>" + key)
        pass
        if key not in shortcut.values() :
            print("Error : key not found : " + key)
            logging.info("Error : key not found : " + key)
            continue
        action = get_key(key)
        if action == "answer_level" :
            cur_elo1 = get_sql_value("importance_elo, date_importance_elo, time_elo, date_time_elo", "id = "+fighters[0])
            cur_elo2 = get_sql_value("importance_elo, date_importance_elo, time_elo, date_time_elo", "id = "+fighters[1])
            cur_K_1 = get_sql_value("K", "id = "+fighters[0])
            cur_K_2 = get_sql_value("K", "id = "+fighters[1])


            new_elo1 = update_elo(cur_elo1, expected(cur_elo1, cur_elo2), int(key), cur_K_1)
            new_elo2 = update_elo(cur_elo2, expected(cur_elo2, cur_elo1), int(key), cur_K_2)
        break
##################################### Main :

###################### initialization :

db = sqlite3.connect('LiTOY.db')
cursor = db.cursor()

logging.info("\n ## Openning db \n")
logging.info("\n ## Creating table if not found \n")
logging.info("\n ## Creating table if not found \n")
query_create_table = 'CREATE TABLE IF NOT EXISTS LiTOY(ID INTEGER, date_added INTEGER, entry TEXT, details TEXT, category TEXT, starred INTEGER, progress TEXT, importance_elo TEXT, date_importance_elo TEXT, time_elo TEXT, date_time_elo TEXT, delta_imp INTEGER, delta_time INTEGER, global_score, time_spent_comparing INTEGER, number_of_comparison INTEGER, disabled INTEGER, done INTEGER, K_value INTEGER)'
logging.info("SQL CREATE REQUEST : " + query_create_table)
cursor.execute(query_create_table)


while 1==1 :
    import_bool =  input("\nDo you want to import new entries from a file? (y/n)\n=> ")
    if import_bool == "y":
        category_list = get_category()
        cat_choice = input("Specify category for the new entries? (default is 'None')\nCategories already found in db : " + category_list + "\n=> ")
        if cat_choice == "" :
            cat_choice = "None"
        filename = input("\nWhat is the name of the file containing the new entries? Press Enter to use default file (new_entry.txt)\n(remember to put it in the same folder!)\n=> ")
        if filename == "" :
            filename = "new_entry.txt"
        print("\n ## Importing from " + filename + "...\n")
        logging.info("\n ## Importing from " + filename + "...\n")
        import_from_txt(filename, cat_choice)
    else :
        print("\n ## No importation to do\n")
        logging.info("\n ## No importation to do\n")
        break

set_db_defaults_value()

# sets all deltas just in case
all_ids = get_sql_value("id")
logging.info("Batch updating all deltas")
for i in all_ids:
    i = list(i)[0]
    update_delta(str(i))
logging.info("Done batch updating all deltas\n")


print(" ## End of initialization\n\n")
print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
print("#######################################################")
print("#######################################################")
print("                                                       ")
#print(pyfiglet.figlet_format("LiTOY",font = "slant"))
#print("~List That Outlives You.~                ")
print(pyfiglet.figlet_format("List That Outlives You.",font = "slant"))
print("                                                       ")
print("#######################################################")
print("#######################################################")
print("\n\n\n\n\n\n\n\n\n\n\n")

###################### main loop :

while 1==1:
    type_of_fight = input("Select mode:\nt = Compare time\ni = Compare importance\n\n\nYour choice => ")
    if type_of_fight !="i" and type_of_fight != "t" :
        print("Incorrect choice\n\n")
        continue
    fighters = choose_fighting_entries(type_of_fight)
    print("\n")
    print("#######################")
    print_entry(fighters[0])
    print("#######################")
    print_entry(fighters[1])
    print("\n\n")
    if type_of_fight == "t":
        user_input = input(question_time + "\n=>")
    if type_of_fight == "i":
        user_input = input(question_importance + "\n=>")
    shortcut_reaction(user_input,type_of_fight, fighters)
    break



################################################################# GRAVEYARD
'''


#query_create = "IF NOT EXISTS (SELECT 1 FROM LiTOY WHERE entry = \"" + entry + "\") BEGIN (INSERT INTO LiTOY(ID, date_added, entry, time_spent_comparing, number_of_comparison, starred, delta) VALUES (" + newID + ", " + unixtime + ", \'" + entry + "\', 0, 0, 0, " + delta_0 + ")) END"
#query_create = "INSERT OR IGNORE INTO LiTOY(ID, date_added, entry, time_spent_comparing, number_of_comparison, starred, category) VALUES (" + newID + ", " + unixtime + ", \'" + entry + "\', 0, 0, 0, 'None' )"
#query_create = str("INSERT INTO LiTOY(ID, date_added, entry, time_spent_comparing, number_of_comparison, starred, delta) VALUES (") + newID + ", " + unixtime + ", \'" + str(entry) + "\', 0, 0, 0, " + delta_0 + ")) END"
#query_create = "'INSERT INTO LiTOY (entry) VALUES ('" + entry + "') EXCEPT (SELECT 1 FROM LiTOY WHERE entry = '" + entry + "')' "
#query_create = "INSERT INTO LiTOY(entry) VALUES ('" + entry + "')"



#real_score =
#3 si rep positive +
#2 si rep positive
#1.5 si match nul
#1 si rep negative
#0 si rep negative +




#cursor.execute('CREATE TABLE IF NOT EXISTS LiTOY(ID INTEGER, date_added INTEGER, entry TEXT, details TEXT, category TEXT, starred INTEGER, progress TEXT, importance_elo TEXT, date_importance_elo TEXT, time_elo TEXT, date_time_elo TEXT, delta_imp INTEGER, delta_time INTEGER, global_score, time_spent_comparing INTEGER, number_of_comparison INTEGER, disabled INTEGER, done INTEGER, UNIQUE(ID, entry))')
# "unique" doesn't seem to work well so I added the workaround to check wether an entry exists



'''
